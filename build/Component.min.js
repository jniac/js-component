const readonly=(a,b,{enumerable:c=!0,configurable:d=!0}={})=>{for(let[e,f]of Object.entries(b))Object.defineProperty(a,e,{value:f,enumerable:c,configurable:d});return a},getter=(a,b,{enumerable:c=!0,configurable:d=!0}={})=>{for(let[e,f]of Object.entries(b))Object.defineProperty(a,e,{get:f,enumerable:c,configurable:d})},getLineage=(a,b=!0)=>{let c=[a];for(;a=a.parent;)b?c.unshift(a):c.push(a);return c};function Average({length:a=10,value:b=0}={}){let c=Array(a);for(let d=0;d<a;d++)c[d]=b;let d=0,e=b*a,f=b,g=b=>(e+=b-c[d],c[d]=b,f=e/a,d++,d===a&&(d=0),f);return{next:g,get array(){return[...c]},get index(){return d},get sum(){return e},get average(){return f}}}const isMethodDefinition=a=>"function"==typeof a||!!("object"==typeof a&&"method"in a),getPrototypeMethod=(a,b)=>{let c=[],d=!1;for(let e of getLineage(a))if(b in e.methods){let a=e.methods[b],{final:f=!1,override:g=!1}=a;if(0===c.length&&"reverse"in a&&(d=a.reverse),g&&(c=[]),c.push("function"==typeof a?a:a.method),f)break}// single
if(1===c.length){let[a]=c;return function(...b){if(this.destroyed)return this;let c=a.apply(this,b);// return {this} by default, for chaining
return void 0===c?this:c}}// multiple
return d&&c.reverse(),function(...a){if(this.destroyed)return this;let b;for(let d of c){let c=d.apply(this,a);void 0!==c&&(b=c)}// return {this} by default, for chaining
return void 0===b?this:b}};let instances=new Set,counter=0,frame=0;const newInstance=(a,b)=>{readonly(a,{uid:counter++});for(let c of getLineage(a.type))c.constructor.apply(a,b);a.dirty=!0,a.start(...b),instances.add(a)},destroyInstance=a=>{instances.delete(a)};let lateUpdateSet=new Set,postUpdateSet=new Set;// instances inside
// callbacks inside
const postUpdate=a=>postUpdateSet.add(a);let currentUpdateComponent;const isLocked=a=>currentUpdateComponent===a;let frameAverage=new Average({length:60});const frameUpdate=()=>{let a=performance.now();requestAnimationFrame(frameUpdate);// UPDATE
for(let a of instances)a.dirty&&(currentUpdateComponent=a,a.dirty=!0===a.update(),lateUpdateSet.add(a));currentUpdateComponent=null;for(let a of postUpdateSet)a();postUpdateSet.clear();// LATE UPDATE
for(let a of lateUpdateSet)a.lateUpdate();lateUpdateSet.clear(),frameAverage.next(performance.now()-a),frame++};frameUpdate();// [name, constructor]
let types={},typeCounter=0,typeMap=new Map;const newType=(a="Component")=>{if(a in types){let b=a,c=1;do a=`${b}_${c++}`;while(a in types)}let b=readonly({},{uid:typeCounter++,name:a,methods:{}});return types[a]=b,{name:a,type:b}},getConstructor=a=>new Function("newInstance","typeMap",`return function ${a}() {

        newInstance(this, arguments)

        // FIXME: if typeMap.has(this.constructor) === false : the prototype has been produced via classic [class] pattern
        // console.log(this, typeMap.has(this.constructor))
        // console.log(Object.getOwnPropertyNames(this.constructor.prototype))

    }`)(newInstance,typeMap),getParent=a=>a?"string"==typeof a?types[a]:"function"==typeof a?typeMap.get(a):a:types.Component,getDescription=a=>{if("string"==typeof a){if(a.includes(":")){let[b,c]=a.split(/\s*:\s*/);return{name:b,extends:c}}return{name:a}}return a||{}},ComponentDefinition=function(a){// IMPORTANT: getParent() must ABSOLUTELY be called before newType, otherwise: "Uncaught TypeError: Cyclic __proto__ value"
let b=getDescription(a.Component),c=getParent(b.extends),{name:d,type:e}=newType(b.name),f=getConstructor(d);readonly(e,{Constructor:f,parent:c,definition:a,constructor:a.constructor}),typeMap.set(f,e),c&&Object.setPrototypeOf(f.prototype,c.Constructor.prototype),readonly(f,{type:e}),readonly(f.prototype,{type:e});for(let b of Object.getOwnPropertyNames(a)){if("Component"===b)continue;if("constructor"===b)continue;let c=Object.getOwnPropertyDescriptor(a,b);if("value"in c){let c=a[b];isMethodDefinition(c)?(e.methods[b]=c,f.prototype[b]=getPrototypeMethod(e,b)):f.prototype[b]=c}else Object.defineProperty(f.prototype,b,c)}return f},RootComponent=ComponentDefinition({Component:"Component",dirty:!1,destroyed:!1,getIdString(){return`${this.type.name}:${this.uid}`},get idString(){return this.getIdString()},constructor(){this.props={},this.state={}},setProps(a){Object.assign(this.props,a)},setState(a,{compare:b=!0}={}){if(isLocked(this))return void postUpdate(()=>this.setState(a,{compare:b}));let{state:c}=this;if(b)for(let[b,d]of Object.entries(a))c[b]!==d&&(c[b]=d,this.dirty=!0);else Object.assign(c,a),this.dirty=!0},forceUpdate(){this.dirty=!0},start:{method(){}},destroy:{reverse:!0,method(){this.destroyed=!0,destroyInstance(this)}},update:{method(){}},lateUpdate:{method(){}}});readonly(RootComponent,{types,instances,frameAverage,Def:ComponentDefinition}),getter(RootComponent,{frame:()=>frame});export default RootComponent;
//# sourceMappingURL=Component.min.js.map
